# âœ… v4.12.9 - Database Schema Compatibility Fix

## ðŸ› Problem

**Symptom:**
- "Schicht zuweisen â†’ Liste hinzufÃ¼gen" funktioniert nicht
- Keine Schichten kÃ¶nnen mehr zugewiesen werden
- 400 Bad Request Errors in Console

**Root Cause:**
```
âŒ work_sessions Tabelle existiert NICHT in DB
âŒ leave_requests.leave_type Spalte existiert NICHT
âŒ Falsche Query-Syntax fÃ¼r Joins
```

**Console Errors:**
```
GET .../work_sessions?select=*&clock_in=gte... â†’ 400 Bad Request
GET .../leave_requests?select=...,users:user_id(...) â†’ 400 Bad Request
```

---

## ðŸ”§ Fix

### **1. EmployeeInfoCard - work_sessions â†’ time_records**

**VORHER (v4.12.8):**
```tsx
interface WorkSession {
  clock_in: string;
  clock_out: string;
  total_minutes: number;
}

// Query
await supabase
  .from('work_sessions')  // âŒ Tabelle existiert nicht
  .select('*')
  .gte('clock_in', ...)   // âŒ Spalte existiert nicht
```

**NACHHER (v4.12.9):**
```tsx
interface TimeRecord {
  date: string;
  time_in: string;
  time_out: string;
  total_hours: number;  // âœ… hours statt minutes
}

// Query
await supabase
  .from('time_records')  // âœ… Korrekte Tabelle
  .select('*')
  .gte('date', ...)      // âœ… Korrekte Spalte
```

---

### **2. WeeklyAbsenceWidget - leave_type â†’ type**

**VORHER (v4.12.8):**
```tsx
interface LeaveRequest {
  leave_type: 'sick' | 'vacation' | 'unpaid';  // âŒ Spalte existiert nicht
}

const LEAVE_TYPE_LABELS = {
  sick: 'Krank',        // âŒ Lowercase
  vacation: 'Urlaub',
  unpaid: 'Unbezahlt'
};

// Query mit Join
await supabase
  .from('leave_requests')
  .select(`
    users:user_id (...)  // âŒ Falsche Join-Syntax
  `)
```

**NACHHER (v4.12.9):**
```tsx
interface LeaveRequest {
  type: 'SICK' | 'VACATION' | 'UNPAID';  // âœ… Korrekte Spalte
}

const LEAVE_TYPE_LABELS = {
  SICK: 'Krank',        // âœ… Uppercase
  VACATION: 'Urlaub',
  UNPAID: 'Unbezahlt'
};

// Query mit separatem Fetch
const { data } = await supabase
  .from('leave_requests')
  .select('id, user_id, type, ...')  // âœ… Kein Join
  
// Dann User-Daten separat fetchen
const { data: usersData } = await supabase
  .from('users')
  .select('id, first_name, last_name, profile_picture')
  .in('id', userIds)
```

---

## ðŸ“Š Database Schema Reference

### **time_records Tabelle:**

```sql
CREATE TABLE public.time_records (
  id UUID PRIMARY KEY,
  user_id UUID REFERENCES users(id),
  date DATE NOT NULL,              -- âœ… Date, not timestamp
  time_in TIME,                    -- âœ… TIME type
  time_out TIME,                   -- âœ… TIME type
  break_minutes INTEGER,
  total_hours DECIMAL(4,2),        -- âœ… HOURS, not minutes
  notes TEXT,
  created_at TIMESTAMP,
  updated_at TIMESTAMP,
  UNIQUE(user_id, date)
);
```

---

### **leave_requests Tabelle:**

```sql
CREATE TABLE public.leave_requests (
  id UUID PRIMARY KEY,
  user_id UUID REFERENCES users(id),
  start_date DATE NOT NULL,
  end_date DATE NOT NULL,
  type TEXT CHECK (type IN ('VACATION', 'SICK', 'UNPAID')),  -- âœ… UPPERCASE
  status TEXT CHECK (status IN ('PENDING', 'APPROVED', 'REJECTED')),
  comment TEXT,
  approved_by UUID,
  approved_at TIMESTAMP,
  team_id UUID,
  created_at TIMESTAMP,
  updated_at TIMESTAMP
);
```

**Wichtig:**
- Spalte heiÃŸt `type`, NICHT `leave_type`
- Werte sind `VACATION`, `SICK`, `UNPAID` (UPPERCASE)
- Kein `UNPAID` in Check Constraint in Original-Migration â†’ Migration 037 fÃ¼gt es hinzu

---

## ðŸ”„ Query Changes

### **EmployeeInfoCard - Time Records Query:**

```tsx
// Monatliche Records
const { data: recordsData, error } = await supabase
  .from('time_records')
  .select('*')
  .eq('user_id', selectedUser.id)
  .gte('date', monthStart)  // âœ… Date Format: 'yyyy-MM-dd'
  .lte('date', monthEnd)
  .order('date', { ascending: false });

// Stunden berechnen
const workedHours = timeRecords
  .filter(r => r.total_hours)
  .reduce((sum, r) => sum + (r.total_hours || 0), 0);
```

**Vorher:**
- âŒ `gte('clock_in', monthStart.toISOString())`
- âŒ `workedMinutes / 60` (Umrechnung nÃ¶tig)

**Nachher:**
- âœ… `gte('date', 'yyyy-MM-dd')` (String Format)
- âœ… `total_hours` direkt verwenden

---

### **WeeklyAbsenceWidget - Leave Requests Query:**

```tsx
// 1. Leave Requests fetchen
const { data, error } = await supabase
  .from('leave_requests')
  .select('id, user_id, type, start_date, end_date, status')
  .eq('status', 'approved')
  .gte('end_date', weekStart)    // âœ… Overlap Logic
  .lte('start_date', weekEnd)
  .order('start_date', { ascending: true });

// 2. User-Daten separat fetchen
const userIds = [...new Set(data.map(item => item.user_id))];
const { data: usersData } = await supabase
  .from('users')
  .select('id, first_name, last_name, profile_picture')
  .in('id', userIds);

// 3. ZusammenfÃ¼hren
const usersMap = new Map(usersData?.map(u => [u.id, u]));
const transformedData = data.map(item => ({
  ...item,
  user: usersMap.get(item.user_id)
}));
```

**Vorher:**
- âŒ `select('..., users:user_id (...)')` â†’ Join-Syntax funktioniert nicht
- âŒ `or(...)` fÃ¼r Overlap â†’ Kompliziert

**Nachher:**
- âœ… Separate Queries fÃ¼r leave_requests und users
- âœ… `gte('end_date', ...)` + `lte('start_date', ...)` fÃ¼r Overlap
- âœ… Map fÃ¼r effizientes ZusammenfÃ¼hren

---

## ðŸ“ˆ Overlap Logic Explained

**Woche:** 03.11.2025 - 09.11.2025

```
Szenario 1: Ãœberschneidung am Anfang
Abwesenheit:  [01.11 -------- 05.11]
Woche:              [03.11 --------- 09.11]
âœ… end_date (05.11) >= weekStart (03.11)
âœ… start_date (01.11) <= weekEnd (09.11)

Szenario 2: Komplett in Woche
Abwesenheit:        [04.11 -- 06.11]
Woche:        [03.11 ---------------- 09.11]
âœ… end_date (06.11) >= weekStart (03.11)
âœ… start_date (04.11) <= weekEnd (09.11)

Szenario 3: Ãœberschneidung am Ende
Abwesenheit:              [08.11 -------- 12.11]
Woche:        [03.11 --------- 09.11]
âœ… end_date (12.11) >= weekStart (03.11)
âœ… start_date (08.11) <= weekEnd (09.11)

Szenario 4: Keine Ãœberschneidung (vor Woche)
Abwesenheit:  [01.11 -- 02.11]
Woche:              [03.11 --------- 09.11]
âŒ end_date (02.11) < weekStart (03.11)
```

**Query Logic:**
```tsx
.gte('end_date', weekStart)    // Endet nicht vor Wochenbeginn
.lte('start_date', weekEnd)    // Beginnt nicht nach Wochenende
```

---

## ðŸŽ¯ Impact

### **VORHER (v4.12.8):**
```
1. User klickt "Schicht zuweisen"
2. EmployeeInfoCard versucht work_sessions zu laden
   â†’ 400 Bad Request
3. Card zeigt keine Daten
4. Schicht-Zuweisung funktioniert nicht
5. WeeklyAbsenceWidget gibt 400 Error
   â†’ Keine Abwesenheiten sichtbar
```

### **NACHHER (v4.12.9):**
```
1. User klickt "Schicht zuweisen"
2. EmployeeInfoCard lÃ¤dt time_records erfolgreich
   âœ“ Zeigt monatliche Stunden
   âœ“ Zeigt letzte AktivitÃ¤t
3. Schicht-Zuweisung funktioniert
4. WeeklyAbsenceWidget zeigt Abwesenheiten
   âœ“ Krank: [ðŸ‘¤] [ðŸ‘¤]
   âœ“ Urlaub: [ðŸ‘¤]
```

---

## ðŸ§ª Testing

### **Test 1: EmployeeInfoCard lÃ¤dt Daten**
1. Ã–ffne Schichtplanung
2. Klicke auf einen Mitarbeiter
3. **Erwartung:** Info-Karte zeigt:
   - Monatliche Stunden (Soll/Ist)
   - Letzter Arbeitstag
   - Durchschn. Schichtzeiten
4. **Erwartung:** KEINE 400 Errors in Console

---

### **Test 2: Schicht-Zuweisung funktioniert**
1. Klicke auf Mitarbeiter
2. Klicke "Schicht zuweisen"
3. WÃ¤hle Schicht aus Liste
4. **Erwartung:** Schicht wird zugewiesen
5. **Erwartung:** Dialog schlieÃŸt sich
6. **Erwartung:** Schicht erscheint im Kalender

---

### **Test 3: Abwesenheits-Widget zeigt Daten**
1. Erstelle Urlaubs-/Krankmeldung
2. Approve in Admin Panel
3. Gehe zu Schichtplanung
4. **Erwartung:** Widget zeigt:
   ```
   Abwesenheiten (1)
   
   Urlaub: (1)
   [ðŸ‘¤]  â† Profilbild mit blauem Ring
   ```
5. **Erwartung:** Hover zeigt Tooltip
6. **Erwartung:** KEINE 400 Errors

---

### **Test 4: Wechsel zwischen Wochen**
1. WÃ¤hle aktuelle Woche
2. Klicke "â†’" fÃ¼r nÃ¤chste Woche
3. **Erwartung:** Widget updated automatisch
4. **Erwartung:** Zeigt Abwesenheiten fÃ¼r neue Woche
5. **Erwartung:** Smooth Transition

---

## ðŸ” Debug Guide

### **Problem: Immer noch 400 Errors**

**Check 1: Tabelle existiert?**
```sql
SELECT table_name 
FROM information_schema.tables 
WHERE table_schema = 'public' 
  AND table_name IN ('time_records', 'leave_requests');
```

**Check 2: Spalten korrekt?**
```sql
-- time_records
SELECT column_name, data_type 
FROM information_schema.columns 
WHERE table_name = 'time_records';

-- Erwartung:
-- date | date
-- time_in | time without time zone
-- time_out | time without time zone
-- total_hours | numeric

-- leave_requests
SELECT column_name, data_type 
FROM information_schema.columns 
WHERE table_name = 'leave_requests';

-- Erwartung:
-- type | text  (NOT leave_type!)
```

**Check 3: Check Constraint?**
```sql
SELECT conname, pg_get_constraintdef(oid) 
FROM pg_constraint 
WHERE conrelid = 'leave_requests'::regclass 
  AND contype = 'c';

-- Erwartung:
-- type IN ('VACATION', 'SICK', 'UNPAID')
```

**Wenn UNPAID fehlt:**
```sql
-- Run Migration 037
ALTER TABLE leave_requests 
DROP CONSTRAINT IF EXISTS leave_requests_type_check;

ALTER TABLE leave_requests 
ADD CONSTRAINT leave_requests_type_check 
CHECK (type IN ('VACATION', 'SICK', 'UNPAID'));
```

---

### **Problem: User-Daten werden nicht geladen**

**Check Map Logic:**
```tsx
console.log('User IDs:', userIds);
console.log('Users Data:', usersData);
console.log('Users Map:', Array.from(usersMap.entries()));
console.log('Transformed Data:', transformedData);
```

**Expected Output:**
```
User IDs: ['uuid-1', 'uuid-2']
Users Data: [
  { id: 'uuid-1', first_name: 'Max', ... },
  { id: 'uuid-2', first_name: 'Anna', ... }
]
Users Map: [
  ['uuid-1', { id: 'uuid-1', first_name: 'Max', ... }],
  ['uuid-2', { id: 'uuid-2', first_name: 'Anna', ... }]
]
Transformed Data: [
  { id: '...', type: 'VACATION', user: { id: 'uuid-1', ... } }
]
```

---

## ðŸ“‹ Migration Status

### **Required Migrations:**

- âœ… **001_initial_schema.sql** - time_records, leave_requests Tabellen
- âœ… **037_add_unpaid_leave_type.sql** - UNPAID zu type Check Constraint

### **Optional aber Empfohlen:**

- âš ï¸ **036_extend_leave_requests.sql** - Erweitert leave_requests mit:
  - `leave_type` ENUM â†’ Veraltet, nutze `type`
  - `historical_approver_id` â†’ FÃ¼r Approval-Historie
  - `created_by` â†’ FÃ¼r Audit-Trail

**Tipp:** Wenn Migration 036 gelaufen ist, existieren BEIDE Spalten:
- `type` (TEXT) â† Nutze diese!
- `leave_type` (ENUM) â† Legacy, ignorieren

---

## âœ… Fixed Files

**Changed:**
1. âœ… `/components/BrowoKo_EmployeeInfoCard.tsx`
   - WorkSession â†’ TimeRecord
   - work_sessions â†’ time_records
   - clock_in/clock_out â†’ date/time_in/time_out
   - total_minutes â†’ total_hours

2. âœ… `/components/BrowoKo_WeeklyAbsenceWidget.tsx`
   - leave_type â†’ type
   - sick/vacation/unpaid â†’ SICK/VACATION/UNPAID
   - Join-Query â†’ Separate Fetches
   - OR Logic â†’ GTE/LTE Logic

---

## ðŸŽ‰ Summary

**Problem:**
- âŒ 400 Bad Request Errors
- âŒ Schicht-Zuweisung funktioniert nicht
- âŒ Keine Abwesenheiten sichtbar

**Root Cause:**
- âŒ Falsche Tabellennamen (work_sessions statt time_records)
- âŒ Falsche Spaltennamen (leave_type statt type, clock_in statt date)
- âŒ Falsche Join-Syntax fÃ¼r Supabase

**Fix:**
- âœ… Korrekte Tabellen-/Spaltennamen
- âœ… Separate Queries statt Joins
- âœ… Korrekte Overlap-Logic

**Impact:**
- ðŸŽ¯ Schicht-Zuweisung funktioniert wieder
- ðŸŽ¯ Mitarbeiter-Infos werden korrekt geladen
- ðŸŽ¯ Abwesenheits-Widget zeigt Daten
- ðŸŽ¯ Keine Console-Errors mehr

---

**Version:** v4.12.9  
**Type:** Bugfix - Database Schema Compatibility  
**Status:** âœ… **COMPLETE - PRODUCTION READY**
